# ============================================================================
# Azure Pipeline for TaskMaster.Contracts
# ============================================================================
# Shared contracts library for TaskMaster microservices
# Publishes NuGet package to Azure Artifacts (tm-packages feed)
# Standardized to match TaskMaster.Platform pattern
# ============================================================================

trigger:
  branches:
    include:
      - main
  tags:
    include:
      - 'v*'
  paths:
    exclude:
      - '**/*.md'
      - 'docs/**'

pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - '**/*.md'
      - 'docs/**'

# Use self-hosted agents for consistency with other TaskMaster repos
pool:
  name: TaskMaster-SelfHosted

variables:
  - group: SemanticRelease-Variables
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '10.0.x'
  - name: feedName
    value: 'tm-packages'
  - name: packageName
    value: 'TaskMaster.Contracts'
  - name: sonarQubeServiceConnection
    value: 'SonarQube-TaskMaster'
  - name: sonarQubeProjectKey
    value: 'taskmaster-contracts'
  - name: sonarQubeProjectName
    value: 'TaskMaster Contracts'

stages:
  # ============================================================================
  # Stage 1: Build and Test
  # ============================================================================
  - stage: Build
    displayName: 'Build & Test'
    jobs:
      - job: BuildTest
        displayName: 'Build, Test, Analyze'
        steps:
          - checkout: self
            fetchDepth: 0
            fetchTags: true

          # Setup .NET
          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: '$(dotnetVersion)'
              includePreviewVersions: true

          # SonarQube Prepare (main branch only)
          - task: SonarQubePrepare@7
            displayName: 'SonarQube Prepare'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              SonarQube: '$(sonarQubeServiceConnection)'
              scannerMode: 'dotnet'
              projectKey: '$(sonarQubeProjectKey)'
              projectName: '$(sonarQubeProjectName)'
              extraProperties: |
                sonar.cs.opencover.reportsPaths=$(Agent.TempDirectory)/**/coverage.opencover.xml

          # Cache NuGet packages
          - task: Cache@2
            displayName: 'Cache NuGet packages'
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)"
              path: '$(HOME)/.nuget/packages'
            continueOnError: true

          # Restore
          - task: DotNetCoreCLI@2
            displayName: 'Restore'
            inputs:
              command: 'restore'
              projects: '**/*.csproj'

          # Build
          - task: DotNetCoreCLI@2
            displayName: 'Build'
            inputs:
              command: 'build'
              projects: '**/*.csproj'
              arguments: '-c $(buildConfiguration) --no-restore'

          # Remove branch.name for SonarQube Community Edition
          - script: |
              FILTERED_PARAMS=$(echo $SONARQUBE_SCANNER_PARAMS | sed 's/"sonar.branch.name":"[^"]*"\,//g')
              echo "##vso[task.setvariable variable=SONARQUBE_SCANNER_PARAMS]$FILTERED_PARAMS"
            displayName: 'Remove branch.name for SonarQube CE'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')

          # SonarQube Analyze
          - task: SonarQubeAnalyze@7
            displayName: 'SonarQube Analyze'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              jdkversion: 'JAVA_HOME_17_X64'

          # SonarQube Publish
          - task: SonarQubePublish@7
            displayName: 'SonarQube Publish'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              pollingTimeoutSec: '300'

          # Quality Gate (PR only - breaks build if fails)
          - task: sonar-buildbreaker@8
            displayName: 'Break build on Quality Gate failure'
            inputs:
              SonarQube: '$(sonarQubeServiceConnection)'
            condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))

  # ============================================================================
  # Stage 2: Semantic Version
  # ============================================================================
  - stage: SemanticRelease
    displayName: 'Get Semantic Version'
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: Release
        displayName: 'Determine Version'
        steps:
          - checkout: self
            fetchDepth: 0
            fetchTags: true

          - script: |
              # Get latest semantic version tag
              LATEST_TAG=$(git tag --sort=-v:refname | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+' | head -1)
              
              if [ -z "$LATEST_TAG" ]; then
                VERSION="1.0.0"
                echo "No existing tags found, using default version: $VERSION"
              else
                VERSION="${LATEST_TAG#v}"
                echo "Found latest tag: $LATEST_TAG -> Version: $VERSION"
              fi
              
              echo "##vso[task.setvariable variable=semanticVersion;isOutput=true]$VERSION"
              echo "Semantic Version: $VERSION"
            name: semver
            displayName: 'Extract Semantic Version'

  # ============================================================================
  # Stage 3: Pack and Publish NuGet
  # ============================================================================
  - stage: PublishNuGet
    displayName: 'Pack & Publish NuGet'
    dependsOn:
      - Build
      - SemanticRelease
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      semanticVersion: $[ stageDependencies.SemanticRelease.Release.outputs['semver.semanticVersion'] ]
    jobs:
      - job: PackPublish
        displayName: 'Pack and Publish to Azure Artifacts'
        steps:
          - checkout: self
            fetchDepth: 0

          # Setup .NET
          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: '$(dotnetVersion)'
              includePreviewVersions: true

          # Restore (needed for pack)
          - task: DotNetCoreCLI@2
            displayName: 'Restore'
            inputs:
              command: 'restore'
              projects: '**/*.csproj'

          # Build
          - task: DotNetCoreCLI@2
            displayName: 'Build'
            inputs:
              command: 'build'
              projects: '**/*.csproj'
              arguments: '-c $(buildConfiguration) --no-restore'

          # Pack NuGet package with version
          - task: DotNetCoreCLI@2
            displayName: 'Pack NuGet Package'
            inputs:
              command: 'pack'
              packagesToPack: 'src/$(packageName)/$(packageName).csproj'
              configuration: '$(buildConfiguration)'
              packDirectory: '$(Build.ArtifactStagingDirectory)/packages'
              nobuild: true
              versioningScheme: 'byEnvVar'
              versionEnvVar: 'semanticVersion'

          # Publish artifact (for traceability)
          - task: PublishPipelineArtifact@1
            displayName: 'Publish NuGet Artifact'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/packages'
              artifact: 'nuget-packages'

          # Push to Azure Artifacts
          - task: NuGetAuthenticate@1
            displayName: 'Authenticate to Azure Artifacts'

          - task: DotNetCoreCLI@2
            displayName: 'Push to Azure Artifacts'
            inputs:
              command: 'push'
              packagesToPush: '$(Build.ArtifactStagingDirectory)/packages/*.nupkg'
              nuGetFeedType: 'internal'
              publishVstsFeed: 'TaskMaster/$(feedName)'
              allowPackageConflicts: true

          # Summary
          - script: |
              echo "=========================================="
              echo "NuGet Package Published Successfully!"
              echo "=========================================="
              echo "Package: $(packageName)"
              echo "Version: $(semanticVersion)"
              echo "Feed: $(feedName)"
              echo ""
              echo "Install with:"
              echo "  dotnet add package $(packageName) --version $(semanticVersion)"
              echo "=========================================="
            displayName: 'Publish Summary'
